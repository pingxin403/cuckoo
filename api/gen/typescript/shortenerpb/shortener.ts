// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.4
// source: shortener.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "api.v1";

/** CreateShortLinkRequest contains parameters for creating a short link */
export interface CreateShortLinkRequest {
  /**
   * long_url is the original URL to be shortened (required)
   *
   * Must use HTTP or HTTPS protocol and be no longer than 2048 characters.
   * The service validates the URL format and checks for malicious patterns.
   */
  longUrl: string;
  /**
   * expires_at is the optional expiration time for the short link
   *
   * If set, the short link will return HTTP 410 Gone after this time.
   * If not set, the link is permanent. Supported range: 1 hour to 10 years.
   */
  expiresAt:
    | Date
    | undefined;
  /**
   * custom_code is an optional custom short code (4-20 characters)
   *
   * If provided, the service will use this code instead of generating one.
   * Must be alphanumeric with optional hyphens, and cannot be a reserved keyword.
   * Returns ALREADY_EXISTS error if the code is already in use.
   */
  customCode: string;
}

/** CreateShortLinkResponse contains the created short link information */
export interface CreateShortLinkResponse {
  /** short_url is the complete short URL (e.g., "https://ex.co/abc123x") */
  shortUrl: string;
  /**
   * short_code is the unique identifier (e.g., "abc123x")
   *
   * This is the 7-character code (or custom code) that maps to the long URL.
   */
  shortCode: string;
  /** created_at is the timestamp when the link was created */
  createdAt:
    | Date
    | undefined;
  /**
   * expires_at is the expiration time if set
   *
   * Only present if an expiration time was specified in the request.
   */
  expiresAt: Date | undefined;
}

/** GetLinkInfoRequest contains parameters for retrieving link information */
export interface GetLinkInfoRequest {
  /** short_code is the unique identifier of the short link (required) */
  shortCode: string;
}

/** GetLinkInfoResponse contains metadata about a short link */
export interface GetLinkInfoResponse {
  /** short_code is the unique identifier */
  shortCode: string;
  /** long_url is the original URL */
  longUrl: string;
  /** created_at is when the link was created */
  createdAt:
    | Date
    | undefined;
  /**
   * expires_at is the expiration time if set
   *
   * Only present if the link has an expiration time.
   */
  expiresAt:
    | Date
    | undefined;
  /**
   * click_count is the approximate number of times the link was accessed
   *
   * This is an eventually consistent count with typical delay of 1-5 seconds.
   * For real-time approximate counts, this value is updated from Redis counters.
   */
  clickCount: number;
  /**
   * is_expired indicates whether the link has expired
   *
   * True if expires_at is set and the current time is past the expiration.
   */
  isExpired: boolean;
}

/** DeleteShortLinkRequest contains parameters for deleting a short link */
export interface DeleteShortLinkRequest {
  /** short_code is the unique identifier of the short link to delete (required) */
  shortCode: string;
}

/** DeleteShortLinkResponse contains the result of the delete operation */
export interface DeleteShortLinkResponse {
  /**
   * success indicates whether the deletion was successful
   *
   * Always true for successful operations. Errors are returned via gRPC status codes.
   */
  success: boolean;
}

function createBaseCreateShortLinkRequest(): CreateShortLinkRequest {
  return { longUrl: "", expiresAt: undefined, customCode: "" };
}

export const CreateShortLinkRequest: MessageFns<CreateShortLinkRequest> = {
  encode(message: CreateShortLinkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.longUrl !== "") {
      writer.uint32(10).string(message.longUrl);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(18).fork()).join();
    }
    if (message.customCode !== "") {
      writer.uint32(26).string(message.customCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateShortLinkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateShortLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.longUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateShortLinkRequest {
    return {
      longUrl: isSet(object.longUrl)
        ? globalThis.String(object.longUrl)
        : isSet(object.long_url)
        ? globalThis.String(object.long_url)
        : "",
      expiresAt: isSet(object.expiresAt)
        ? fromJsonTimestamp(object.expiresAt)
        : isSet(object.expires_at)
        ? fromJsonTimestamp(object.expires_at)
        : undefined,
      customCode: isSet(object.customCode)
        ? globalThis.String(object.customCode)
        : isSet(object.custom_code)
        ? globalThis.String(object.custom_code)
        : "",
    };
  },

  toJSON(message: CreateShortLinkRequest): unknown {
    const obj: any = {};
    if (message.longUrl !== "") {
      obj.longUrl = message.longUrl;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.customCode !== "") {
      obj.customCode = message.customCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateShortLinkRequest>, I>>(base?: I): CreateShortLinkRequest {
    return CreateShortLinkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateShortLinkRequest>, I>>(object: I): CreateShortLinkRequest {
    const message = createBaseCreateShortLinkRequest();
    message.longUrl = object.longUrl ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    message.customCode = object.customCode ?? "";
    return message;
  },
};

function createBaseCreateShortLinkResponse(): CreateShortLinkResponse {
  return { shortUrl: "", shortCode: "", createdAt: undefined, expiresAt: undefined };
}

export const CreateShortLinkResponse: MessageFns<CreateShortLinkResponse> = {
  encode(message: CreateShortLinkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shortUrl !== "") {
      writer.uint32(10).string(message.shortUrl);
    }
    if (message.shortCode !== "") {
      writer.uint32(18).string(message.shortCode);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateShortLinkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateShortLinkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shortUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shortCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateShortLinkResponse {
    return {
      shortUrl: isSet(object.shortUrl)
        ? globalThis.String(object.shortUrl)
        : isSet(object.short_url)
        ? globalThis.String(object.short_url)
        : "",
      shortCode: isSet(object.shortCode)
        ? globalThis.String(object.shortCode)
        : isSet(object.short_code)
        ? globalThis.String(object.short_code)
        : "",
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      expiresAt: isSet(object.expiresAt)
        ? fromJsonTimestamp(object.expiresAt)
        : isSet(object.expires_at)
        ? fromJsonTimestamp(object.expires_at)
        : undefined,
    };
  },

  toJSON(message: CreateShortLinkResponse): unknown {
    const obj: any = {};
    if (message.shortUrl !== "") {
      obj.shortUrl = message.shortUrl;
    }
    if (message.shortCode !== "") {
      obj.shortCode = message.shortCode;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateShortLinkResponse>, I>>(base?: I): CreateShortLinkResponse {
    return CreateShortLinkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateShortLinkResponse>, I>>(object: I): CreateShortLinkResponse {
    const message = createBaseCreateShortLinkResponse();
    message.shortUrl = object.shortUrl ?? "";
    message.shortCode = object.shortCode ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseGetLinkInfoRequest(): GetLinkInfoRequest {
  return { shortCode: "" };
}

export const GetLinkInfoRequest: MessageFns<GetLinkInfoRequest> = {
  encode(message: GetLinkInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shortCode !== "") {
      writer.uint32(10).string(message.shortCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLinkInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLinkInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shortCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLinkInfoRequest {
    return {
      shortCode: isSet(object.shortCode)
        ? globalThis.String(object.shortCode)
        : isSet(object.short_code)
        ? globalThis.String(object.short_code)
        : "",
    };
  },

  toJSON(message: GetLinkInfoRequest): unknown {
    const obj: any = {};
    if (message.shortCode !== "") {
      obj.shortCode = message.shortCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLinkInfoRequest>, I>>(base?: I): GetLinkInfoRequest {
    return GetLinkInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLinkInfoRequest>, I>>(object: I): GetLinkInfoRequest {
    const message = createBaseGetLinkInfoRequest();
    message.shortCode = object.shortCode ?? "";
    return message;
  },
};

function createBaseGetLinkInfoResponse(): GetLinkInfoResponse {
  return { shortCode: "", longUrl: "", createdAt: undefined, expiresAt: undefined, clickCount: 0, isExpired: false };
}

export const GetLinkInfoResponse: MessageFns<GetLinkInfoResponse> = {
  encode(message: GetLinkInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shortCode !== "") {
      writer.uint32(10).string(message.shortCode);
    }
    if (message.longUrl !== "") {
      writer.uint32(18).string(message.longUrl);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(34).fork()).join();
    }
    if (message.clickCount !== 0) {
      writer.uint32(40).int64(message.clickCount);
    }
    if (message.isExpired !== false) {
      writer.uint32(48).bool(message.isExpired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLinkInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLinkInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shortCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.longUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.clickCount = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isExpired = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLinkInfoResponse {
    return {
      shortCode: isSet(object.shortCode)
        ? globalThis.String(object.shortCode)
        : isSet(object.short_code)
        ? globalThis.String(object.short_code)
        : "",
      longUrl: isSet(object.longUrl)
        ? globalThis.String(object.longUrl)
        : isSet(object.long_url)
        ? globalThis.String(object.long_url)
        : "",
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      expiresAt: isSet(object.expiresAt)
        ? fromJsonTimestamp(object.expiresAt)
        : isSet(object.expires_at)
        ? fromJsonTimestamp(object.expires_at)
        : undefined,
      clickCount: isSet(object.clickCount)
        ? globalThis.Number(object.clickCount)
        : isSet(object.click_count)
        ? globalThis.Number(object.click_count)
        : 0,
      isExpired: isSet(object.isExpired)
        ? globalThis.Boolean(object.isExpired)
        : isSet(object.is_expired)
        ? globalThis.Boolean(object.is_expired)
        : false,
    };
  },

  toJSON(message: GetLinkInfoResponse): unknown {
    const obj: any = {};
    if (message.shortCode !== "") {
      obj.shortCode = message.shortCode;
    }
    if (message.longUrl !== "") {
      obj.longUrl = message.longUrl;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.clickCount !== 0) {
      obj.clickCount = Math.round(message.clickCount);
    }
    if (message.isExpired !== false) {
      obj.isExpired = message.isExpired;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLinkInfoResponse>, I>>(base?: I): GetLinkInfoResponse {
    return GetLinkInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLinkInfoResponse>, I>>(object: I): GetLinkInfoResponse {
    const message = createBaseGetLinkInfoResponse();
    message.shortCode = object.shortCode ?? "";
    message.longUrl = object.longUrl ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.clickCount = object.clickCount ?? 0;
    message.isExpired = object.isExpired ?? false;
    return message;
  },
};

function createBaseDeleteShortLinkRequest(): DeleteShortLinkRequest {
  return { shortCode: "" };
}

export const DeleteShortLinkRequest: MessageFns<DeleteShortLinkRequest> = {
  encode(message: DeleteShortLinkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shortCode !== "") {
      writer.uint32(10).string(message.shortCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteShortLinkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteShortLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shortCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteShortLinkRequest {
    return {
      shortCode: isSet(object.shortCode)
        ? globalThis.String(object.shortCode)
        : isSet(object.short_code)
        ? globalThis.String(object.short_code)
        : "",
    };
  },

  toJSON(message: DeleteShortLinkRequest): unknown {
    const obj: any = {};
    if (message.shortCode !== "") {
      obj.shortCode = message.shortCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteShortLinkRequest>, I>>(base?: I): DeleteShortLinkRequest {
    return DeleteShortLinkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteShortLinkRequest>, I>>(object: I): DeleteShortLinkRequest {
    const message = createBaseDeleteShortLinkRequest();
    message.shortCode = object.shortCode ?? "";
    return message;
  },
};

function createBaseDeleteShortLinkResponse(): DeleteShortLinkResponse {
  return { success: false };
}

export const DeleteShortLinkResponse: MessageFns<DeleteShortLinkResponse> = {
  encode(message: DeleteShortLinkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteShortLinkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteShortLinkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteShortLinkResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteShortLinkResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteShortLinkResponse>, I>>(base?: I): DeleteShortLinkResponse {
    return DeleteShortLinkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteShortLinkResponse>, I>>(object: I): DeleteShortLinkResponse {
    const message = createBaseDeleteShortLinkResponse();
    message.success = object.success ?? false;
    return message;
  },
};

/**
 * ShortenerService provides URL shortening functionality
 *
 * This service transforms long URLs into short, memorable links and provides
 * fast redirection. It supports custom short codes, expiration times, and
 * basic analytics.
 */
export interface ShortenerService {
  /**
   * CreateShortLink creates a new short link from a long URL
   *
   * Generates a unique 7-character short code (or uses a custom code if provided)
   * and stores the mapping. The service validates the URL format and checks for
   * malicious patterns before creating the link.
   *
   * Example:
   *   Request: { long_url: "https://example.com/very/long/path" }
   *   Response: { short_url: "https://ex.co/abc123x", short_code: "abc123x", ... }
   *
   *   Request: { long_url: "https://example.com", custom_code: "promo2024" }
   *   Response: { short_url: "https://ex.co/promo2024", short_code: "promo2024", ... }
   *
   * Errors:
   *   - INVALID_ARGUMENT: Invalid URL format, URL too long (>2048 chars), or malicious pattern detected
   *   - ALREADY_EXISTS: Custom code already in use (HTTP 409)
   *   - RESOURCE_EXHAUSTED: Rate limit exceeded (HTTP 429)
   *   - INTERNAL: Failed to generate unique code after retries
   */
  CreateShortLink(request: CreateShortLinkRequest): Promise<CreateShortLinkResponse>;
  /**
   * GetLinkInfo retrieves metadata for a short link
   *
   * Returns information about a short link including the original URL,
   * creation time, expiration time (if set), and click statistics.
   *
   * Example:
   *   Request: { short_code: "abc123x" }
   *   Response: { short_code: "abc123x", long_url: "https://example.com", click_count: 42, ... }
   *
   * Errors:
   *   - INVALID_ARGUMENT: Empty or invalid short code
   *   - NOT_FOUND: Short code does not exist
   */
  GetLinkInfo(request: GetLinkInfoRequest): Promise<GetLinkInfoResponse>;
  /**
   * DeleteShortLink removes a short link
   *
   * Performs a soft delete of the short link, making it inaccessible for future
   * redirects. The operation is idempotent - deleting an already deleted link
   * returns success.
   *
   * Example:
   *   Request: { short_code: "abc123x" }
   *   Response: { success: true }
   *
   * Errors:
   *   - INVALID_ARGUMENT: Empty or invalid short code
   *   - NOT_FOUND: Short code does not exist
   */
  DeleteShortLink(request: DeleteShortLinkRequest): Promise<DeleteShortLinkResponse>;
}

export const ShortenerServiceServiceName = "api.v1.ShortenerService";
export class ShortenerServiceClientImpl implements ShortenerService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ShortenerServiceServiceName;
    this.rpc = rpc;
    this.CreateShortLink = this.CreateShortLink.bind(this);
    this.GetLinkInfo = this.GetLinkInfo.bind(this);
    this.DeleteShortLink = this.DeleteShortLink.bind(this);
  }
  CreateShortLink(request: CreateShortLinkRequest): Promise<CreateShortLinkResponse> {
    const data = CreateShortLinkRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateShortLink", data);
    return promise.then((data) => CreateShortLinkResponse.decode(new BinaryReader(data)));
  }

  GetLinkInfo(request: GetLinkInfoRequest): Promise<GetLinkInfoResponse> {
    const data = GetLinkInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLinkInfo", data);
    return promise.then((data) => GetLinkInfoResponse.decode(new BinaryReader(data)));
  }

  DeleteShortLink(request: DeleteShortLinkRequest): Promise<DeleteShortLinkResponse> {
    const data = DeleteShortLinkRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteShortLink", data);
    return promise.then((data) => DeleteShortLinkResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
