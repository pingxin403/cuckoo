// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.4
// source: user.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "user.v1";

/** UserStatus represents the user's current status. */
export enum UserStatus {
  USER_STATUS_UNSPECIFIED = 0,
  USER_STATUS_ONLINE = 1,
  USER_STATUS_OFFLINE = 2,
  USER_STATUS_AWAY = 3,
  USER_STATUS_BUSY = 4,
  UNRECOGNIZED = -1,
}

export function userStatusFromJSON(object: any): UserStatus {
  switch (object) {
    case 0:
    case "USER_STATUS_UNSPECIFIED":
      return UserStatus.USER_STATUS_UNSPECIFIED;
    case 1:
    case "USER_STATUS_ONLINE":
      return UserStatus.USER_STATUS_ONLINE;
    case 2:
    case "USER_STATUS_OFFLINE":
      return UserStatus.USER_STATUS_OFFLINE;
    case 3:
    case "USER_STATUS_AWAY":
      return UserStatus.USER_STATUS_AWAY;
    case 4:
    case "USER_STATUS_BUSY":
      return UserStatus.USER_STATUS_BUSY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserStatus.UNRECOGNIZED;
  }
}

export function userStatusToJSON(object: UserStatus): string {
  switch (object) {
    case UserStatus.USER_STATUS_UNSPECIFIED:
      return "USER_STATUS_UNSPECIFIED";
    case UserStatus.USER_STATUS_ONLINE:
      return "USER_STATUS_ONLINE";
    case UserStatus.USER_STATUS_OFFLINE:
      return "USER_STATUS_OFFLINE";
    case UserStatus.USER_STATUS_AWAY:
      return "USER_STATUS_AWAY";
    case UserStatus.USER_STATUS_BUSY:
      return "USER_STATUS_BUSY";
    case UserStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** GroupRole represents the user's role in a group. */
export enum GroupRole {
  GROUP_ROLE_UNSPECIFIED = 0,
  GROUP_ROLE_MEMBER = 1,
  GROUP_ROLE_ADMIN = 2,
  GROUP_ROLE_OWNER = 3,
  UNRECOGNIZED = -1,
}

export function groupRoleFromJSON(object: any): GroupRole {
  switch (object) {
    case 0:
    case "GROUP_ROLE_UNSPECIFIED":
      return GroupRole.GROUP_ROLE_UNSPECIFIED;
    case 1:
    case "GROUP_ROLE_MEMBER":
      return GroupRole.GROUP_ROLE_MEMBER;
    case 2:
    case "GROUP_ROLE_ADMIN":
      return GroupRole.GROUP_ROLE_ADMIN;
    case 3:
    case "GROUP_ROLE_OWNER":
      return GroupRole.GROUP_ROLE_OWNER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GroupRole.UNRECOGNIZED;
  }
}

export function groupRoleToJSON(object: GroupRole): string {
  switch (object) {
    case GroupRole.GROUP_ROLE_UNSPECIFIED:
      return "GROUP_ROLE_UNSPECIFIED";
    case GroupRole.GROUP_ROLE_MEMBER:
      return "GROUP_ROLE_MEMBER";
    case GroupRole.GROUP_ROLE_ADMIN:
      return "GROUP_ROLE_ADMIN";
    case GroupRole.GROUP_ROLE_OWNER:
      return "GROUP_ROLE_OWNER";
    case GroupRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** UserErrorCode defines error codes for user service operations. */
export enum UserErrorCode {
  /** USER_ERROR_CODE_UNSPECIFIED - No error */
  USER_ERROR_CODE_UNSPECIFIED = 0,
  /** USER_ERROR_CODE_USER_NOT_FOUND - User not found */
  USER_ERROR_CODE_USER_NOT_FOUND = 1,
  /** USER_ERROR_CODE_GROUP_NOT_FOUND - Group not found */
  USER_ERROR_CODE_GROUP_NOT_FOUND = 2,
  /** USER_ERROR_CODE_INVALID_REQUEST - Invalid request parameters */
  USER_ERROR_CODE_INVALID_REQUEST = 3,
  /** USER_ERROR_CODE_DATABASE_ERROR - Database error */
  USER_ERROR_CODE_DATABASE_ERROR = 4,
  /** USER_ERROR_CODE_TOO_MANY_IDS - Too many user IDs in batch request (max 100) */
  USER_ERROR_CODE_TOO_MANY_IDS = 5,
  /** USER_ERROR_CODE_INTERNAL_ERROR - Internal server error */
  USER_ERROR_CODE_INTERNAL_ERROR = 6,
  UNRECOGNIZED = -1,
}

export function userErrorCodeFromJSON(object: any): UserErrorCode {
  switch (object) {
    case 0:
    case "USER_ERROR_CODE_UNSPECIFIED":
      return UserErrorCode.USER_ERROR_CODE_UNSPECIFIED;
    case 1:
    case "USER_ERROR_CODE_USER_NOT_FOUND":
      return UserErrorCode.USER_ERROR_CODE_USER_NOT_FOUND;
    case 2:
    case "USER_ERROR_CODE_GROUP_NOT_FOUND":
      return UserErrorCode.USER_ERROR_CODE_GROUP_NOT_FOUND;
    case 3:
    case "USER_ERROR_CODE_INVALID_REQUEST":
      return UserErrorCode.USER_ERROR_CODE_INVALID_REQUEST;
    case 4:
    case "USER_ERROR_CODE_DATABASE_ERROR":
      return UserErrorCode.USER_ERROR_CODE_DATABASE_ERROR;
    case 5:
    case "USER_ERROR_CODE_TOO_MANY_IDS":
      return UserErrorCode.USER_ERROR_CODE_TOO_MANY_IDS;
    case 6:
    case "USER_ERROR_CODE_INTERNAL_ERROR":
      return UserErrorCode.USER_ERROR_CODE_INTERNAL_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserErrorCode.UNRECOGNIZED;
  }
}

export function userErrorCodeToJSON(object: UserErrorCode): string {
  switch (object) {
    case UserErrorCode.USER_ERROR_CODE_UNSPECIFIED:
      return "USER_ERROR_CODE_UNSPECIFIED";
    case UserErrorCode.USER_ERROR_CODE_USER_NOT_FOUND:
      return "USER_ERROR_CODE_USER_NOT_FOUND";
    case UserErrorCode.USER_ERROR_CODE_GROUP_NOT_FOUND:
      return "USER_ERROR_CODE_GROUP_NOT_FOUND";
    case UserErrorCode.USER_ERROR_CODE_INVALID_REQUEST:
      return "USER_ERROR_CODE_INVALID_REQUEST";
    case UserErrorCode.USER_ERROR_CODE_DATABASE_ERROR:
      return "USER_ERROR_CODE_DATABASE_ERROR";
    case UserErrorCode.USER_ERROR_CODE_TOO_MANY_IDS:
      return "USER_ERROR_CODE_TOO_MANY_IDS";
    case UserErrorCode.USER_ERROR_CODE_INTERNAL_ERROR:
      return "USER_ERROR_CODE_INTERNAL_ERROR";
    case UserErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** GetUserRequest contains the user ID to retrieve. */
export interface GetUserRequest {
  /** User ID to retrieve */
  userId: string;
}

/** GetUserResponse contains the user profile information. */
export interface GetUserResponse {
  /** User profile */
  user:
    | UserProfile
    | undefined;
  /** Error code if retrieval failed */
  errorCode: UserErrorCode;
  /** Human-readable error message */
  errorMessage: string;
}

/** BatchGetUsersRequest contains multiple user IDs to retrieve. */
export interface BatchGetUsersRequest {
  /** List of user IDs to retrieve (max 100) */
  userIds: string[];
}

/** BatchGetUsersResponse contains multiple user profiles. */
export interface BatchGetUsersResponse {
  /** Map of user_id to user profile */
  users: { [key: string]: UserProfile };
  /** List of user IDs that were not found */
  notFoundUserIds: string[];
  /** Error code if retrieval failed */
  errorCode: UserErrorCode;
  /** Human-readable error message */
  errorMessage: string;
}

export interface BatchGetUsersResponse_UsersEntry {
  key: string;
  value: UserProfile | undefined;
}

/** GetGroupMembersRequest contains the group ID and pagination parameters. */
export interface GetGroupMembersRequest {
  /** Group ID */
  groupId: string;
  /** Pagination cursor (empty for first page) */
  cursor: string;
  /** Page size (default: 100, max: 1000) */
  limit: number;
}

/** GetGroupMembersResponse contains the list of group members. */
export interface GetGroupMembersResponse {
  /** List of group members */
  members: GroupMember[];
  /** Next page cursor (empty if no more pages) */
  nextCursor: string;
  /** Total member count */
  totalCount: number;
  /** Whether there are more pages */
  hasMore: boolean;
  /** Error code if retrieval failed */
  errorCode: UserErrorCode;
  /** Human-readable error message */
  errorMessage: string;
}

/** ValidateGroupMembershipRequest checks if a user is in a group. */
export interface ValidateGroupMembershipRequest {
  /** User ID to check */
  userId: string;
  /** Group ID to check */
  groupId: string;
}

/** ValidateGroupMembershipResponse contains the membership validation result. */
export interface ValidateGroupMembershipResponse {
  /** Whether the user is a member of the group */
  isMember: boolean;
  /** Group member details if user is a member */
  member:
    | GroupMember
    | undefined;
  /** Error code if validation failed */
  errorCode: UserErrorCode;
  /** Human-readable error message */
  errorMessage: string;
}

/** UserProfile contains user profile information. */
export interface UserProfile {
  /** User ID */
  userId: string;
  /** Username */
  username: string;
  /** Display name */
  displayName: string;
  /** Avatar URL */
  avatarUrl: string;
  /** User status (online, offline, away, busy) */
  status: UserStatus;
  /** Account creation timestamp */
  createdAt:
    | Date
    | undefined;
  /** Last updated timestamp */
  updatedAt: Date | undefined;
}

/** GroupMember contains group membership information. */
export interface GroupMember {
  /** User ID */
  userId: string;
  /** Group ID */
  groupId: string;
  /** Member role (owner, admin, member) */
  role: GroupRole;
  /** Display name in group (optional, overrides user display_name) */
  groupDisplayName: string;
  /** When the user joined the group */
  joinedAt:
    | Date
    | undefined;
  /** Whether the user is muted in the group */
  isMuted: boolean;
}

function createBaseGetUserRequest(): GetUserRequest {
  return { userId: "" };
}

export const GetUserRequest: MessageFns<GetUserRequest> = {
  encode(message: GetUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
    };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUserResponse(): GetUserResponse {
  return { user: undefined, errorCode: 0, errorMessage: "" };
}

export const GetUserResponse: MessageFns<GetUserResponse> = {
  encode(message: GetUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserProfile.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.errorCode !== 0) {
      writer.uint32(16).int32(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserProfile.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserResponse {
    return {
      user: isSet(object.user) ? UserProfile.fromJSON(object.user) : undefined,
      errorCode: isSet(object.errorCode)
        ? userErrorCodeFromJSON(object.errorCode)
        : isSet(object.error_code)
        ? userErrorCodeFromJSON(object.error_code)
        : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
    };
  },

  toJSON(message: GetUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserProfile.toJSON(message.user);
    }
    if (message.errorCode !== 0) {
      obj.errorCode = userErrorCodeToJSON(message.errorCode);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserResponse>, I>>(base?: I): GetUserResponse {
    return GetUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserResponse>, I>>(object: I): GetUserResponse {
    const message = createBaseGetUserResponse();
    message.user = (object.user !== undefined && object.user !== null)
      ? UserProfile.fromPartial(object.user)
      : undefined;
    message.errorCode = object.errorCode ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseBatchGetUsersRequest(): BatchGetUsersRequest {
  return { userIds: [] };
}

export const BatchGetUsersRequest: MessageFns<BatchGetUsersRequest> = {
  encode(message: BatchGetUsersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGetUsersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetUsersRequest {
    return {
      userIds: globalThis.Array.isArray(object?.userIds)
        ? object.userIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.user_ids)
        ? object.user_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BatchGetUsersRequest): unknown {
    const obj: any = {};
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchGetUsersRequest>, I>>(base?: I): BatchGetUsersRequest {
    return BatchGetUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchGetUsersRequest>, I>>(object: I): BatchGetUsersRequest {
    const message = createBaseBatchGetUsersRequest();
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseBatchGetUsersResponse(): BatchGetUsersResponse {
  return { users: {}, notFoundUserIds: [], errorCode: 0, errorMessage: "" };
}

export const BatchGetUsersResponse: MessageFns<BatchGetUsersResponse> = {
  encode(message: BatchGetUsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.users).forEach(([key, value]: [string, UserProfile]) => {
      BatchGetUsersResponse_UsersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    for (const v of message.notFoundUserIds) {
      writer.uint32(18).string(v!);
    }
    if (message.errorCode !== 0) {
      writer.uint32(24).int32(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGetUsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = BatchGetUsersResponse_UsersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.users[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.notFoundUserIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetUsersResponse {
    return {
      users: isObject(object.users)
        ? (globalThis.Object.entries(object.users) as [string, any][]).reduce(
          (acc: { [key: string]: UserProfile }, [key, value]: [string, any]) => {
            acc[key] = UserProfile.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      notFoundUserIds: globalThis.Array.isArray(object?.notFoundUserIds)
        ? object.notFoundUserIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.not_found_user_ids)
        ? object.not_found_user_ids.map((e: any) => globalThis.String(e))
        : [],
      errorCode: isSet(object.errorCode)
        ? userErrorCodeFromJSON(object.errorCode)
        : isSet(object.error_code)
        ? userErrorCodeFromJSON(object.error_code)
        : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
    };
  },

  toJSON(message: BatchGetUsersResponse): unknown {
    const obj: any = {};
    if (message.users) {
      const entries = globalThis.Object.entries(message.users) as [string, UserProfile][];
      if (entries.length > 0) {
        obj.users = {};
        entries.forEach(([k, v]) => {
          obj.users[k] = UserProfile.toJSON(v);
        });
      }
    }
    if (message.notFoundUserIds?.length) {
      obj.notFoundUserIds = message.notFoundUserIds;
    }
    if (message.errorCode !== 0) {
      obj.errorCode = userErrorCodeToJSON(message.errorCode);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchGetUsersResponse>, I>>(base?: I): BatchGetUsersResponse {
    return BatchGetUsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchGetUsersResponse>, I>>(object: I): BatchGetUsersResponse {
    const message = createBaseBatchGetUsersResponse();
    message.users = (globalThis.Object.entries(object.users ?? {}) as [string, UserProfile][]).reduce(
      (acc: { [key: string]: UserProfile }, [key, value]: [string, UserProfile]) => {
        if (value !== undefined) {
          acc[key] = UserProfile.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.notFoundUserIds = object.notFoundUserIds?.map((e) => e) || [];
    message.errorCode = object.errorCode ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseBatchGetUsersResponse_UsersEntry(): BatchGetUsersResponse_UsersEntry {
  return { key: "", value: undefined };
}

export const BatchGetUsersResponse_UsersEntry: MessageFns<BatchGetUsersResponse_UsersEntry> = {
  encode(message: BatchGetUsersResponse_UsersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      UserProfile.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGetUsersResponse_UsersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetUsersResponse_UsersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = UserProfile.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetUsersResponse_UsersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? UserProfile.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BatchGetUsersResponse_UsersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = UserProfile.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchGetUsersResponse_UsersEntry>, I>>(
    base?: I,
  ): BatchGetUsersResponse_UsersEntry {
    return BatchGetUsersResponse_UsersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchGetUsersResponse_UsersEntry>, I>>(
    object: I,
  ): BatchGetUsersResponse_UsersEntry {
    const message = createBaseBatchGetUsersResponse_UsersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? UserProfile.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetGroupMembersRequest(): GetGroupMembersRequest {
  return { groupId: "", cursor: "", limit: 0 };
}

export const GetGroupMembersRequest: MessageFns<GetGroupMembersRequest> = {
  encode(message: GetGroupMembersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== "") {
      writer.uint32(10).string(message.groupId);
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMembersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMembersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMembersRequest {
    return {
      groupId: isSet(object.groupId)
        ? globalThis.String(object.groupId)
        : isSet(object.group_id)
        ? globalThis.String(object.group_id)
        : "",
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: GetGroupMembersRequest): unknown {
    const obj: any = {};
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMembersRequest>, I>>(base?: I): GetGroupMembersRequest {
    return GetGroupMembersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMembersRequest>, I>>(object: I): GetGroupMembersRequest {
    const message = createBaseGetGroupMembersRequest();
    message.groupId = object.groupId ?? "";
    message.cursor = object.cursor ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseGetGroupMembersResponse(): GetGroupMembersResponse {
  return { members: [], nextCursor: "", totalCount: 0, hasMore: false, errorCode: 0, errorMessage: "" };
}

export const GetGroupMembersResponse: MessageFns<GetGroupMembersResponse> = {
  encode(message: GetGroupMembersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      GroupMember.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextCursor !== "") {
      writer.uint32(18).string(message.nextCursor);
    }
    if (message.totalCount !== 0) {
      writer.uint32(24).int32(message.totalCount);
    }
    if (message.hasMore !== false) {
      writer.uint32(32).bool(message.hasMore);
    }
    if (message.errorCode !== 0) {
      writer.uint32(40).int32(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(50).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMembersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMembersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(GroupMember.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hasMore = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMembersResponse {
    return {
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e: any) => GroupMember.fromJSON(e)) : [],
      nextCursor: isSet(object.nextCursor)
        ? globalThis.String(object.nextCursor)
        : isSet(object.next_cursor)
        ? globalThis.String(object.next_cursor)
        : "",
      totalCount: isSet(object.totalCount)
        ? globalThis.Number(object.totalCount)
        : isSet(object.total_count)
        ? globalThis.Number(object.total_count)
        : 0,
      hasMore: isSet(object.hasMore)
        ? globalThis.Boolean(object.hasMore)
        : isSet(object.has_more)
        ? globalThis.Boolean(object.has_more)
        : false,
      errorCode: isSet(object.errorCode)
        ? userErrorCodeFromJSON(object.errorCode)
        : isSet(object.error_code)
        ? userErrorCodeFromJSON(object.error_code)
        : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
    };
  },

  toJSON(message: GetGroupMembersResponse): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => GroupMember.toJSON(e));
    }
    if (message.nextCursor !== "") {
      obj.nextCursor = message.nextCursor;
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.hasMore !== false) {
      obj.hasMore = message.hasMore;
    }
    if (message.errorCode !== 0) {
      obj.errorCode = userErrorCodeToJSON(message.errorCode);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMembersResponse>, I>>(base?: I): GetGroupMembersResponse {
    return GetGroupMembersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMembersResponse>, I>>(object: I): GetGroupMembersResponse {
    const message = createBaseGetGroupMembersResponse();
    message.members = object.members?.map((e) => GroupMember.fromPartial(e)) || [];
    message.nextCursor = object.nextCursor ?? "";
    message.totalCount = object.totalCount ?? 0;
    message.hasMore = object.hasMore ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseValidateGroupMembershipRequest(): ValidateGroupMembershipRequest {
  return { userId: "", groupId: "" };
}

export const ValidateGroupMembershipRequest: MessageFns<ValidateGroupMembershipRequest> = {
  encode(message: ValidateGroupMembershipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateGroupMembershipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateGroupMembershipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateGroupMembershipRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      groupId: isSet(object.groupId)
        ? globalThis.String(object.groupId)
        : isSet(object.group_id)
        ? globalThis.String(object.group_id)
        : "",
    };
  },

  toJSON(message: ValidateGroupMembershipRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateGroupMembershipRequest>, I>>(base?: I): ValidateGroupMembershipRequest {
    return ValidateGroupMembershipRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateGroupMembershipRequest>, I>>(
    object: I,
  ): ValidateGroupMembershipRequest {
    const message = createBaseValidateGroupMembershipRequest();
    message.userId = object.userId ?? "";
    message.groupId = object.groupId ?? "";
    return message;
  },
};

function createBaseValidateGroupMembershipResponse(): ValidateGroupMembershipResponse {
  return { isMember: false, member: undefined, errorCode: 0, errorMessage: "" };
}

export const ValidateGroupMembershipResponse: MessageFns<ValidateGroupMembershipResponse> = {
  encode(message: ValidateGroupMembershipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isMember !== false) {
      writer.uint32(8).bool(message.isMember);
    }
    if (message.member !== undefined) {
      GroupMember.encode(message.member, writer.uint32(18).fork()).join();
    }
    if (message.errorCode !== 0) {
      writer.uint32(24).int32(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateGroupMembershipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateGroupMembershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isMember = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.member = GroupMember.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateGroupMembershipResponse {
    return {
      isMember: isSet(object.isMember)
        ? globalThis.Boolean(object.isMember)
        : isSet(object.is_member)
        ? globalThis.Boolean(object.is_member)
        : false,
      member: isSet(object.member) ? GroupMember.fromJSON(object.member) : undefined,
      errorCode: isSet(object.errorCode)
        ? userErrorCodeFromJSON(object.errorCode)
        : isSet(object.error_code)
        ? userErrorCodeFromJSON(object.error_code)
        : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
    };
  },

  toJSON(message: ValidateGroupMembershipResponse): unknown {
    const obj: any = {};
    if (message.isMember !== false) {
      obj.isMember = message.isMember;
    }
    if (message.member !== undefined) {
      obj.member = GroupMember.toJSON(message.member);
    }
    if (message.errorCode !== 0) {
      obj.errorCode = userErrorCodeToJSON(message.errorCode);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateGroupMembershipResponse>, I>>(base?: I): ValidateGroupMembershipResponse {
    return ValidateGroupMembershipResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateGroupMembershipResponse>, I>>(
    object: I,
  ): ValidateGroupMembershipResponse {
    const message = createBaseValidateGroupMembershipResponse();
    message.isMember = object.isMember ?? false;
    message.member = (object.member !== undefined && object.member !== null)
      ? GroupMember.fromPartial(object.member)
      : undefined;
    message.errorCode = object.errorCode ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseUserProfile(): UserProfile {
  return {
    userId: "",
    username: "",
    displayName: "",
    avatarUrl: "",
    status: 0,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const UserProfile: MessageFns<UserProfile> = {
  encode(message: UserProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(34).string(message.avatarUrl);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      displayName: isSet(object.displayName)
        ? globalThis.String(object.displayName)
        : isSet(object.display_name)
        ? globalThis.String(object.display_name)
        : "",
      avatarUrl: isSet(object.avatarUrl)
        ? globalThis.String(object.avatarUrl)
        : isSet(object.avatar_url)
        ? globalThis.String(object.avatar_url)
        : "",
      status: isSet(object.status) ? userStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      updatedAt: isSet(object.updatedAt)
        ? fromJsonTimestamp(object.updatedAt)
        : isSet(object.updated_at)
        ? fromJsonTimestamp(object.updated_at)
        : undefined,
    };
  },

  toJSON(message: UserProfile): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.status !== 0) {
      obj.status = userStatusToJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfile>, I>>(base?: I): UserProfile {
    return UserProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfile>, I>>(object: I): UserProfile {
    const message = createBaseUserProfile();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.displayName = object.displayName ?? "";
    message.avatarUrl = object.avatarUrl ?? "";
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGroupMember(): GroupMember {
  return { userId: "", groupId: "", role: 0, groupDisplayName: "", joinedAt: undefined, isMuted: false };
}

export const GroupMember: MessageFns<GroupMember> = {
  encode(message: GroupMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    if (message.role !== 0) {
      writer.uint32(24).int32(message.role);
    }
    if (message.groupDisplayName !== "") {
      writer.uint32(34).string(message.groupDisplayName);
    }
    if (message.joinedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.joinedAt), writer.uint32(42).fork()).join();
    }
    if (message.isMuted !== false) {
      writer.uint32(48).bool(message.isMuted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupDisplayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.joinedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isMuted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMember {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      groupId: isSet(object.groupId)
        ? globalThis.String(object.groupId)
        : isSet(object.group_id)
        ? globalThis.String(object.group_id)
        : "",
      role: isSet(object.role) ? groupRoleFromJSON(object.role) : 0,
      groupDisplayName: isSet(object.groupDisplayName)
        ? globalThis.String(object.groupDisplayName)
        : isSet(object.group_display_name)
        ? globalThis.String(object.group_display_name)
        : "",
      joinedAt: isSet(object.joinedAt)
        ? fromJsonTimestamp(object.joinedAt)
        : isSet(object.joined_at)
        ? fromJsonTimestamp(object.joined_at)
        : undefined,
      isMuted: isSet(object.isMuted)
        ? globalThis.Boolean(object.isMuted)
        : isSet(object.is_muted)
        ? globalThis.Boolean(object.is_muted)
        : false,
    };
  },

  toJSON(message: GroupMember): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.role !== 0) {
      obj.role = groupRoleToJSON(message.role);
    }
    if (message.groupDisplayName !== "") {
      obj.groupDisplayName = message.groupDisplayName;
    }
    if (message.joinedAt !== undefined) {
      obj.joinedAt = message.joinedAt.toISOString();
    }
    if (message.isMuted !== false) {
      obj.isMuted = message.isMuted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMember>, I>>(base?: I): GroupMember {
    return GroupMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMember>, I>>(object: I): GroupMember {
    const message = createBaseGroupMember();
    message.userId = object.userId ?? "";
    message.groupId = object.groupId ?? "";
    message.role = object.role ?? 0;
    message.groupDisplayName = object.groupDisplayName ?? "";
    message.joinedAt = object.joinedAt ?? undefined;
    message.isMuted = object.isMuted ?? false;
    return message;
  },
};

/** UserService provides user profile and group membership management. */
export interface UserService {
  /** GetUser retrieves a single user's profile information. */
  GetUser(request: GetUserRequest): Promise<GetUserResponse>;
  /** BatchGetUsers retrieves multiple users' profiles in a single request. */
  BatchGetUsers(request: BatchGetUsersRequest): Promise<BatchGetUsersResponse>;
  /** GetGroupMembers retrieves all members of a group with pagination support. */
  GetGroupMembers(request: GetGroupMembersRequest): Promise<GetGroupMembersResponse>;
  /** ValidateGroupMembership checks if a user is a member of a specific group. */
  ValidateGroupMembership(request: ValidateGroupMembershipRequest): Promise<ValidateGroupMembershipResponse>;
}

export const UserServiceServiceName = "user.v1.UserService";
export class UserServiceClientImpl implements UserService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || UserServiceServiceName;
    this.rpc = rpc;
    this.GetUser = this.GetUser.bind(this);
    this.BatchGetUsers = this.BatchGetUsers.bind(this);
    this.GetGroupMembers = this.GetGroupMembers.bind(this);
    this.ValidateGroupMembership = this.ValidateGroupMembership.bind(this);
  }
  GetUser(request: GetUserRequest): Promise<GetUserResponse> {
    const data = GetUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUser", data);
    return promise.then((data) => GetUserResponse.decode(new BinaryReader(data)));
  }

  BatchGetUsers(request: BatchGetUsersRequest): Promise<BatchGetUsersResponse> {
    const data = BatchGetUsersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BatchGetUsers", data);
    return promise.then((data) => BatchGetUsersResponse.decode(new BinaryReader(data)));
  }

  GetGroupMembers(request: GetGroupMembersRequest): Promise<GetGroupMembersResponse> {
    const data = GetGroupMembersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetGroupMembers", data);
    return promise.then((data) => GetGroupMembersResponse.decode(new BinaryReader(data)));
  }

  ValidateGroupMembership(request: ValidateGroupMembershipRequest): Promise<ValidateGroupMembershipResponse> {
    const data = ValidateGroupMembershipRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidateGroupMembership", data);
    return promise.then((data) => ValidateGroupMembershipResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
