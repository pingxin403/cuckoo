// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.4
// source: todo.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "api.v1";

/**
 * Todo 表示一个 TODO 任务项
 *
 * 每个 TODO 任务都有唯一的 ID，包含标题、描述、完成状态和时间戳。
 */
export interface Todo {
  /**
   * id 是 TODO 任务的唯一标识符
   *
   * 由服务器在创建时自动生成（UUID 格式）。
   * 客户端不应该设置此字段。
   */
  id: string;
  /**
   * title 是 TODO 任务的标题
   *
   * 必填字段，不能为空或仅包含空格。
   * 建议长度不超过 200 个字符。
   */
  title: string;
  /**
   * description 是 TODO 任务的详细描述
   *
   * 可选字段，可以包含任务的详细信息。
   * 建议长度不超过 1000 个字符。
   */
  description: string;
  /**
   * completed 表示任务是否已完成
   *
   * 默认值为 false（未完成）。
   */
  completed: boolean;
  /**
   * created_at 是任务的创建时间
   *
   * 由服务器在创建时自动设置，客户端不应修改。
   */
  createdAt:
    | Date
    | undefined;
  /**
   * updated_at 是任务的最后更新时间
   *
   * 由服务器在创建和每次更新时自动设置，客户端不应修改。
   */
  updatedAt: Date | undefined;
}

/** CreateTodoRequest 包含创建 TODO 任务的参数 */
export interface CreateTodoRequest {
  /** title 是新 TODO 任务的标题（必填） */
  title: string;
  /** description 是新 TODO 任务的描述（可选） */
  description: string;
}

/** CreateTodoResponse 包含创建的 TODO 任务 */
export interface CreateTodoResponse {
  /** todo 是新创建的 TODO 任务，包含生成的 ID 和时间戳 */
  todo: Todo | undefined;
}

/**
 * ListTodosRequest 包含查询 TODO 列表的参数
 *
 * 当前版本不支持分页，返回所有任务。
 * 未来版本可能添加分页参数（page_size, page_token）。
 */
export interface ListTodosRequest {
}

/** ListTodosResponse 包含 TODO 任务列表 */
export interface ListTodosResponse {
  /**
   * todos 是所有 TODO 任务的列表
   *
   * 任务按创建时间降序排列（最新的在前）。
   */
  todos: Todo[];
}

/** UpdateTodoRequest 包含更新 TODO 任务的参数 */
export interface UpdateTodoRequest {
  /** id 是要更新的 TODO 任务的唯一标识符（必填） */
  id: string;
  /** title 是更新后的标题（必填） */
  title: string;
  /** description 是更新后的描述（可选） */
  description: string;
  /** completed 是更新后的完成状态 */
  completed: boolean;
}

/** UpdateTodoResponse 包含更新后的 TODO 任务 */
export interface UpdateTodoResponse {
  /** todo 是更新后的 TODO 任务，包含新的 updated_at 时间戳 */
  todo: Todo | undefined;
}

/** DeleteTodoRequest 包含删除 TODO 任务的参数 */
export interface DeleteTodoRequest {
  /** id 是要删除的 TODO 任务的唯一标识符（必填） */
  id: string;
}

/** DeleteTodoResponse 包含删除操作的结果 */
export interface DeleteTodoResponse {
  /**
   * success 表示删除操作是否成功
   *
   * 通常为 true。如果 TODO 不存在，会返回 NOT_FOUND 错误而不是此响应。
   */
  success: boolean;
}

function createBaseTodo(): Todo {
  return { id: "", title: "", description: "", completed: false, createdAt: undefined, updatedAt: undefined };
}

export const Todo: MessageFns<Todo> = {
  encode(message: Todo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.completed !== false) {
      writer.uint32(32).bool(message.completed);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Todo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTodo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Todo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      updatedAt: isSet(object.updatedAt)
        ? fromJsonTimestamp(object.updatedAt)
        : isSet(object.updated_at)
        ? fromJsonTimestamp(object.updated_at)
        : undefined,
    };
  },

  toJSON(message: Todo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Todo>, I>>(base?: I): Todo {
    return Todo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Todo>, I>>(object: I): Todo {
    const message = createBaseTodo();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.completed = object.completed ?? false;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseCreateTodoRequest(): CreateTodoRequest {
  return { title: "", description: "" };
}

export const CreateTodoRequest: MessageFns<CreateTodoRequest> = {
  encode(message: CreateTodoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTodoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTodoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTodoRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: CreateTodoRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTodoRequest>, I>>(base?: I): CreateTodoRequest {
    return CreateTodoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTodoRequest>, I>>(object: I): CreateTodoRequest {
    const message = createBaseCreateTodoRequest();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCreateTodoResponse(): CreateTodoResponse {
  return { todo: undefined };
}

export const CreateTodoResponse: MessageFns<CreateTodoResponse> = {
  encode(message: CreateTodoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.todo !== undefined) {
      Todo.encode(message.todo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTodoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTodoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.todo = Todo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTodoResponse {
    return { todo: isSet(object.todo) ? Todo.fromJSON(object.todo) : undefined };
  },

  toJSON(message: CreateTodoResponse): unknown {
    const obj: any = {};
    if (message.todo !== undefined) {
      obj.todo = Todo.toJSON(message.todo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTodoResponse>, I>>(base?: I): CreateTodoResponse {
    return CreateTodoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTodoResponse>, I>>(object: I): CreateTodoResponse {
    const message = createBaseCreateTodoResponse();
    message.todo = (object.todo !== undefined && object.todo !== null) ? Todo.fromPartial(object.todo) : undefined;
    return message;
  },
};

function createBaseListTodosRequest(): ListTodosRequest {
  return {};
}

export const ListTodosRequest: MessageFns<ListTodosRequest> = {
  encode(_: ListTodosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTodosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTodosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListTodosRequest {
    return {};
  },

  toJSON(_: ListTodosRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTodosRequest>, I>>(base?: I): ListTodosRequest {
    return ListTodosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTodosRequest>, I>>(_: I): ListTodosRequest {
    const message = createBaseListTodosRequest();
    return message;
  },
};

function createBaseListTodosResponse(): ListTodosResponse {
  return { todos: [] };
}

export const ListTodosResponse: MessageFns<ListTodosResponse> = {
  encode(message: ListTodosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.todos) {
      Todo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTodosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTodosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.todos.push(Todo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTodosResponse {
    return { todos: globalThis.Array.isArray(object?.todos) ? object.todos.map((e: any) => Todo.fromJSON(e)) : [] };
  },

  toJSON(message: ListTodosResponse): unknown {
    const obj: any = {};
    if (message.todos?.length) {
      obj.todos = message.todos.map((e) => Todo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTodosResponse>, I>>(base?: I): ListTodosResponse {
    return ListTodosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTodosResponse>, I>>(object: I): ListTodosResponse {
    const message = createBaseListTodosResponse();
    message.todos = object.todos?.map((e) => Todo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateTodoRequest(): UpdateTodoRequest {
  return { id: "", title: "", description: "", completed: false };
}

export const UpdateTodoRequest: MessageFns<UpdateTodoRequest> = {
  encode(message: UpdateTodoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.completed !== false) {
      writer.uint32(32).bool(message.completed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTodoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTodoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTodoRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
    };
  },

  toJSON(message: UpdateTodoRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTodoRequest>, I>>(base?: I): UpdateTodoRequest {
    return UpdateTodoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTodoRequest>, I>>(object: I): UpdateTodoRequest {
    const message = createBaseUpdateTodoRequest();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseUpdateTodoResponse(): UpdateTodoResponse {
  return { todo: undefined };
}

export const UpdateTodoResponse: MessageFns<UpdateTodoResponse> = {
  encode(message: UpdateTodoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.todo !== undefined) {
      Todo.encode(message.todo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTodoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTodoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.todo = Todo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTodoResponse {
    return { todo: isSet(object.todo) ? Todo.fromJSON(object.todo) : undefined };
  },

  toJSON(message: UpdateTodoResponse): unknown {
    const obj: any = {};
    if (message.todo !== undefined) {
      obj.todo = Todo.toJSON(message.todo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTodoResponse>, I>>(base?: I): UpdateTodoResponse {
    return UpdateTodoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTodoResponse>, I>>(object: I): UpdateTodoResponse {
    const message = createBaseUpdateTodoResponse();
    message.todo = (object.todo !== undefined && object.todo !== null) ? Todo.fromPartial(object.todo) : undefined;
    return message;
  },
};

function createBaseDeleteTodoRequest(): DeleteTodoRequest {
  return { id: "" };
}

export const DeleteTodoRequest: MessageFns<DeleteTodoRequest> = {
  encode(message: DeleteTodoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTodoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTodoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTodoRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteTodoRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTodoRequest>, I>>(base?: I): DeleteTodoRequest {
    return DeleteTodoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTodoRequest>, I>>(object: I): DeleteTodoRequest {
    const message = createBaseDeleteTodoRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteTodoResponse(): DeleteTodoResponse {
  return { success: false };
}

export const DeleteTodoResponse: MessageFns<DeleteTodoResponse> = {
  encode(message: DeleteTodoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTodoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTodoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTodoResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteTodoResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTodoResponse>, I>>(base?: I): DeleteTodoResponse {
    return DeleteTodoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTodoResponse>, I>>(object: I): DeleteTodoResponse {
    const message = createBaseDeleteTodoResponse();
    message.success = object.success ?? false;
    return message;
  },
};

/**
 * TodoService 提供 TODO 任务管理功能
 *
 * 该服务支持完整的 CRUD 操作，允许用户创建、查询、更新和删除 TODO 任务。
 * 所有任务都有唯一的 ID，并记录创建和更新时间。
 */
export interface TodoService {
  /**
   * CreateTodo 创建新的 TODO 任务
   *
   * 创建一个新的 TODO 项并返回包含生成的唯一 ID 和时间戳的完整对象。
   * 标题字段是必需的，不能为空。
   *
   * Example:
   *   Request: { title: "Buy groceries", description: "Milk, eggs, bread" }
   *   Response: { todo: { id: "uuid", title: "Buy groceries", ... } }
   *
   * Errors:
   *   - INVALID_ARGUMENT: 如果标题为空或仅包含空格
   */
  CreateTodo(request: CreateTodoRequest): Promise<CreateTodoResponse>;
  /**
   * ListTodos 获取所有 TODO 任务
   *
   * 返回系统中所有 TODO 任务的列表。任务按创建时间排序（最新的在前）。
   *
   * Example:
   *   Request: {}
   *   Response: { todos: [{ id: "1", title: "Task 1" }, ...] }
   */
  ListTodos(request: ListTodosRequest): Promise<ListTodosResponse>;
  /**
   * UpdateTodo 更新现有的 TODO 任务
   *
   * 更新指定 ID 的 TODO 任务。可以更新标题、描述和完成状态。
   * 更新操作会自动更新 updated_at 时间戳。
   *
   * Example:
   *   Request: { id: "uuid", title: "Updated title", completed: true }
   *   Response: { todo: { id: "uuid", title: "Updated title", completed: true, ... } }
   *
   * Errors:
   *   - NOT_FOUND: 如果指定的 TODO 不存在
   *   - INVALID_ARGUMENT: 如果 ID 为空或标题为空
   */
  UpdateTodo(request: UpdateTodoRequest): Promise<UpdateTodoResponse>;
  /**
   * DeleteTodo 删除指定的 TODO 任务
   *
   * 根据 ID 删除 TODO 任务。删除操作是幂等的，重复删除同一个 ID 不会报错。
   *
   * Example:
   *   Request: { id: "uuid" }
   *   Response: { success: true }
   *
   * Errors:
   *   - NOT_FOUND: 如果指定的 TODO 不存在
   *   - INVALID_ARGUMENT: 如果 ID 为空
   */
  DeleteTodo(request: DeleteTodoRequest): Promise<DeleteTodoResponse>;
}

export const TodoServiceServiceName = "api.v1.TodoService";
export class TodoServiceClientImpl implements TodoService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || TodoServiceServiceName;
    this.rpc = rpc;
    this.CreateTodo = this.CreateTodo.bind(this);
    this.ListTodos = this.ListTodos.bind(this);
    this.UpdateTodo = this.UpdateTodo.bind(this);
    this.DeleteTodo = this.DeleteTodo.bind(this);
  }
  CreateTodo(request: CreateTodoRequest): Promise<CreateTodoResponse> {
    const data = CreateTodoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateTodo", data);
    return promise.then((data) => CreateTodoResponse.decode(new BinaryReader(data)));
  }

  ListTodos(request: ListTodosRequest): Promise<ListTodosResponse> {
    const data = ListTodosRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListTodos", data);
    return promise.then((data) => ListTodosResponse.decode(new BinaryReader(data)));
  }

  UpdateTodo(request: UpdateTodoRequest): Promise<UpdateTodoResponse> {
    const data = UpdateTodoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateTodo", data);
    return promise.then((data) => UpdateTodoResponse.decode(new BinaryReader(data)));
  }

  DeleteTodo(request: DeleteTodoRequest): Promise<DeleteTodoResponse> {
    const data = DeleteTodoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteTodo", data);
    return promise.then((data) => DeleteTodoResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
